[TOC]

## 8.1基本介绍

用户一年的签到记录，如果用String类型存储，那你需要365个key/value,操作起来麻烦。通过位图可以有效地简化这个操作。

它的统计很简单:

每天的记录占一个位，365天就是365个位，大概就是46个字节。这样可以有效地节省存储空间，如果有一天想要统计用户一共签到了多少天，统计1的个数即可。

对于位图的操作，可以直接操作对应的的字符串(get/set)，也可以直接操作位(getbit/setbit),

## 8.2基本操作

Redis的基本操作可以分为两大类:

### 8.2.1 零存整取

例如存储一个java字符串:

| 字符 | ascii |  二进制  |
| :--: | :---: | :------: |
|  J   |  74   | 01001010 |
|  a   |  97   | 01100001 |
|  v   |  118  | 01110110 |

接下来去存储

![61400195857](C:\Users\85183\AppData\Local\Temp\1614001958572.png)

### 8.2.2 整存零取

存一个字符串进去，但是通过位操作获取字符串

## 8.3统计

例如签到记录:

01111000111

1 表示当天签到了，0 表示未签到，统计总的签到天数:

可以使用Bitcount来统计

![61400214497](C:\Users\85183\AppData\Local\Temp\1614002144970.png)

bitcount可以统计起始位置，但是注意，这起始位置是指字符的起始位置，不是二进制的起始位置。

除了Bitcount之外，还有一个bitpos,他可以返回第一个指定二进制第一次出现的位置。这个命令中的起始位置同bitcount.

## 8.4 Bit批处理操作

Redis 3.2 之后新加了一个功能叫做Bitfield，可以对Bit进行批量操作。

例如:

BITFIELD name get u4 0

表示获取name中的位，从0开始获取，获取4个位，返回一个无符号数字。

- u 表示无符号数字
- i 表示有符号数字

bitfield 也可以一次执行多个操作。

**GET**

bitfiled 也可以一次执行多个操作。

BITFIELD name get u8 0

**SET**

BITFIELD  name set u8 8 98

**INCRBY**

对置顶范围进行自增操作，自增操作可能会出现溢出，既可能是向上溢出，也可能是向下溢出。Redis 中对于溢出的处理方案是折返。8 位无符号数 255 加 1 溢出变为 0；8 位有符号数 127，加 1 变为-128.

也可以修改默认的溢出策略，可以改为 fail ，表示执行失败。

~~~
BITFIELD name overflow fail incrby u2 6 1
~~~


sat 表示留在在最大/最小值。

~~~
BITFIELD name overflow sat incrby u2 6 1
~~~



