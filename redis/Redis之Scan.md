[TOC]

## 1.简单介绍
scan实际上是keys 的一个升级版。

可以用Keys 查询key,在查询的过程中可以使用通配符。keys 虽然用着还算方便，但是没有分页功能。同时因为Redis是单线程，所以key 的执行会比较消耗时间，特别是当数据量大的时候，影响整个程序的运行。

为了解决keys 存在的问题，从Redis 2.8 开始，引入了scan。

scan 具备Keys 的功能，但是不会阻塞线程，而且可以控制每次返回的结果数。

## 2.基本用法
首先准备一万条测试数据:
~~~java
public class ScanTest {
    public static void main(String[] args) {
        Redis redis = new Redis();
        redis.execute(jedis -> {
            for (int i = 0; i < 10000; i++) {
                jedis.set("k" + i,"v" + i);
            }
        });
    }
}
~~~

scan 命令一共提供了三个参数，第一个 cursor,第二个参数 key,第三个参数是 limit。

cursor 实际上是指一维数组的位置索引，limit 则是遍历的一维数组个数，所以每次返回的数据大小可能不确定。
~~~
127.0.0.1:6379> scan 0 match k8* count 1000
~~~

## 3.原理
scan 的遍历顺序。

假设目前有三条数据:
~~~
127.0.0.1:6379> set db_number v1
OK
127.0.0.1:6379> set key1 key1
OK
127.0.0.1:6379> set mykey mykey
OK
127.0.0.1:6379> keys *
1) "key1"
2) "db_number"
3) "mykey"
127.0.0.1:6379> scan 0 match * count 1
1) "2"
2) 1) "key1"
127.0.0.1:6379> scan 2 match * count 1
1) "1"
2) 1) "db_number"
127.0.0.1:6379> scan 1 match * count 1
1) "0"
~~~

在遍历过成功，游标顺序为0 2 1 3，从十进制看没规律，但从二进制看是有规律的:

这种规律就是高位进1，传统的二进制加法，是从右往左加，这里是从左往右加。

实际上，在Redis中，它的具体计算流程是这样的:

1.将要计算的数字反转

2.给反转后的数字加1

3.再反转

那为什么不是按0，1,2,3,4这样的顺序呢，主要考虑两个问题:

1.字典扩容

2.字典缩容

假如我们将要访问 110 时，发生了扩容，此时scan 就会从0110开始遍历，之前已经被遍历过的元素就不会被重复遍历了。

假如我们将要访问110时，发生了缩容，此时scan 就会从 10 开始遍历，这个时候也会遍历到 010，但是 010 之前的不会再被遍历了。所以在发生缩容的时候，可能会返回重复的元素。

## 4.其他用法
Scan 是一系列的指令，除了遍历所有的key 之外，也可以遍历某一个类型的 key ，对应的命令有:

- zscan:zset
- hscan:hash
- sscan:set