[TOC]

## 1.阻塞IO与非阻塞IO
Java 在JDK1.4中引入NIO,但是也有很多人在使用阻塞IO，这两种IO 有什么区别？

在阻塞模式下，如果你从数据流中读取不到指定大小的数据量，IO就会阻塞。比如已知会有10个字节发送过来，但是我目前只收到4个，还剩6个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收到4个字节，但是读到 4个字节就会立即返回，不会傻傻等着，等另外6个字节来的时候，再去继续读取。

所以阻塞IO性能低于非阻塞IO。

如果有一个Web服务器，使用阻塞IO来处理请求，那么每一个请求都需要开启一个新的线程，但是如果使用了非阻塞IO，基本上一个小小线程池就够用了。因为不会发生阻塞，每一个线程都能够高效的利用。 

## 2.Redis的线程模型

首先一点，Redis是单线程。单线程如何解决高并发问题的？

实际上，能够处理高并发的单线程应用不仅仅是Redis，除了Redis之外，还有NodeJS,nginx等等也是单线程。

Redis 虽然是单线程，但是运行很快，主要原因如下:
- Redis中的所有数据都是基于内存的，所有的计算也都是内存级别的计算，所以快。
- Redis 是单线程的，所以有一些时间复杂度高的指令，可能会导致Redis卡顿，例如keys。
- Redis 处理并发的客户端连接时，使用了非阻塞IO。

在使用非阻塞IO时，有一个问题，就是线程如何知道剩下的数据来了？

这里就涉及到一个新的概念叫**多路复用**，本质上就是一个事件轮询API。
- Redis 会给每一个客户端指令通过队列来排队，进行顺序处理。
- Redis 做出响应时，也会有一个响应的队列。